<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\Http\Response.js - Firefly</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="Firefly"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Cookie.html">Cookie</a></li>
            
                <li><a href="..&#x2F;classes/Firefly.html">Firefly</a></li>
            
                <li><a href="..&#x2F;classes/Handlebars.html">Handlebars</a></li>
            
                <li><a href="..&#x2F;classes/Mailer.html">Mailer</a></li>
            
                <li><a href="..&#x2F;classes/Mongoose.html">Mongoose</a></li>
            
                <li><a href="..&#x2F;classes/Permission.html">Permission</a></li>
            
                <li><a href="..&#x2F;classes/RenderManager.html">RenderManager</a></li>
            
                <li><a href="..&#x2F;classes/Request.html">Request</a></li>
            
                <li><a href="..&#x2F;classes/Response.html">Response</a></li>
            
                <li><a href="..&#x2F;classes/Router.html">Router</a></li>
            
                <li><a href="..&#x2F;classes/Server.html">Server</a></li>
            
                <li><a href="..&#x2F;classes/SessionManager.html">SessionManager</a></li>
            
                <li><a href="..&#x2F;classes/WSServer.html">WSServer</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Core.html">Core</a></li>
            
                <li><a href="..&#x2F;modules/Services.html">Services</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\Http\Response.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
    Firefly - Node.js CMS
    Copyright (C) &lt;2012&gt;  &lt;Mansoor Sayed&gt;

    This program is free software: you can redistribute it and&#x2F;or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see &lt;http:&#x2F;&#x2F;www.gnu.org&#x2F;licenses&#x2F;&gt;.
*&#x2F;

&#x27;use strict&#x27;;

var Cookie = require( &#x27;.&#x2F;Cookie.js&#x27; );


&#x2F;**
* Response object constructor
*
* @class Response
* @module Core
* @constructor
* @param {Object} res Native node response object
*&#x2F;
var Response = module.exports = function( resNative, fReq, firefly ) {
    this._response = resNative;
    this._request = fReq;
    this._firefly = firefly;
    
    this._cookies = {};
    &#x2F;&#x2F;default content type
    this._contentType = &#x27;text&#x2F;html&#x27;;
    
    this._cacheControl = {};
    
    this._encoding = &#x27;utf8&#x27;;
    
    this._charset = &#x27;UTF-8&#x27;;
    
    this._response.statusCode = 200;
    
    this._sent = false;
};



&#x2F;**
* Creates a string represnetaion of the response object including both 
*            content and header sections. **This is broken**
*
* @method toString
* @param {String} String representation of HTTP response
*&#x2F;
Response.prototype.toString = function() {
    return JSON.stringify( this._response );
};



&#x2F;**
* Exposes the native Node response object
*
* @method getNativeResponse
* @param {Object} Native Node esponse object
*&#x2F;
Response.prototype.getNativeResponse = function() {
    return this._response;    
};



&#x2F;**
* Get age of the response
*
* @method getAge
* @return {Number | undefined} Header&#x27;s value as a type Number, if none is found 
*           then &#x60;undefined&#x60; is returned
*&#x2F;
Response.prototype.getAge = function() {
    var age;
    if ( this.get( &#x27;Age&#x27; ) !== undefined ) {
        age = this.get( &#x27;Age&#x27; ) &gt;&gt; 0;
    }
    return age;
};



&#x2F;**
* Get the name of the encoding
*
* @method getEncoding
* @return {String} encoding
*&#x2F;
Response.prototype.getEncoding = function() {
    return this._encoding;
};



&#x2F;**
* Change the value of the response&#x27;s encoding, default is &#x60;utf8&#x60;
*
* @method setEncoding
* @return {String} encoding to use
*&#x2F;
Response.prototype.setEncoding = function( encoding ) {
    this._encoding = encoding;
};



&#x2F;**
* Get content of the response object
*
* @method getContent
* @return {String} Content of response object
*&#x2F;
Response.prototype.getContent = function() {
    return this._content;
};


&#x2F;**
* Set the value of the &#x60;Date&#x60; HTTP header
*
* @method setDate
* @param {Date} date Value to set as the value of &#x60;Date&#x60; header
*&#x2F;
Response.prototype.setDate = function( date ) {
    this.setHeaderDate( date);
};



&#x2F;**
* Get a Date object with the value of the &#x60;Date&#x60; HTTP header
*
* @method getDate
* @return {Date} value of &#x60;Date&#x60; header
*&#x2F;
Response.prototype.getDate = function() {
    return this.getHeaderDate( &#x27;Date&#x27; );
};



&#x2F;**
* Get the value of a HTTP header as a Date object.. if it is a valid representaion of a date
*
* @method getHeaderDate
* @param {String} header Name of http header for which to get date value
* @param {Date} defaultValue Date object to be returned incase the specified HTTP header
            does not exist or is empty
* @return {Date} Requested date
*&#x2F;
Response.prototype.getHeaderDate = function( header, defaultValue ) {
    var date = this.get( header );
    if ( !date ) {
        return defaultValue;
    }
    date = Date.parse( date );
    if ( isNaN( date ) ) {
        throw Error( &#x27;name: &quot;Bad  Date&quot;, description: &quot;Cannot parse malformed date representation&quot;&#x27; );
    }
    
    return new Date( date );
};



&#x2F;**
* Set the value of the specified header to the value of the specified Date object (UTC representation)
*
* @method setHeaderDate
* @param {String} header Name of header field
* @param {Date} data date value
* @return {Date} value of &#x60;Date&#x60; header
*&#x2F;
Response.prototype.setHeaderDate = function( header, date ) {
    this.setHeader( header, date.toUTCString() );
};



&#x2F;**
* Get the value of the Etag header value
*
* @method getEtag
* @return {String} value of &#x60;Etag&#x60; HTTP header
*&#x2F;
Response.prototype.getEtag = function() {
    return this.getHeader( &#x27;Etag&#x27; );
};



&#x2F;**
* Get the value of the &#x60;Expires&#x60; header as a Date object
*
* @method getExpires
* @return {Date} Response expiration date
*&#x2F;
Response.prototype.getExpires = function() {
    return this.getHeaderDate( &#x27;Expires&#x27; );
};



&#x2F;**
* Get the maximum time after which the response will be considered stale as a Date object.
*           First, it checks for a &#x60;s-maxage&#x60; directive, then a &#x60;max-age&#x60; directive, and then it falls
*           back on an &#x60;expires&#x60; header. &#x60;undefined&#x60; is returned when no maximum age can be established.
*
* @method getMaxAge
* @return {String} String representation of HTTP response
*&#x2F;
Response.prototype.getMaxAge = function() {
    var age;
    if ( (age = getCacheControlDirective(&#x27;s-maxage&#x27;)) !== null ) {
        return age;    
    }
    
    if ( (age = getCacheControlDirective( &#x27;max-age&#x27; )) !== null ) {
        return age;
    }
    
    return this.getExpires();
};




&#x2F;**
* Get the response&#x27;s HTTP status code
*
* @method getStatusCode
* @return {Number} Status code
*&#x2F;
Response.prototype.getStatusCode = function() {
    return this._response.statusCode;
};




&#x2F;**
* Get the lety HTTP header&#x27;s values in an array 
*
* @method getlety
* @return {Array} lety values
*&#x2F;
Response.prototype.getlety = function() {
    var lety = this.get( &#x27;lety&#x27; ) || &#x27;&#x27;;

    return lety.split( &#x27;, &#x27; );
};



&#x2F;**
* Set the &#x60;lety&#x60; header
*
* @method setlety
* @param {Array | String} headers An Array or String containing list of headers.
            if it is a string then the headers must be comma seperated
*&#x2F;
Response.prototype.setlety = function( headers ) {
    this.set( &#x27;lety&#x27;, headers.join( &#x27;, &#x27; ) );
};



&#x2F;**
* Determin if the response is cachable
*
* @method isCachable
* @return {Boolean} is response cachable
*&#x2F;
Response.prototype.isCachable = function() {
    
};



&#x2F;**
* Determine if the response is fresh
*
* @method isFresh
* @return {Boolean} True if it is fresh, otherwise false
*&#x2F;
Response.prototype.isFresh = function() {
    return this.getTtl &gt; 0;
};



&#x2F;**
* Determine if the response includes headers that can be used to validate
*            the response with the origin server using a conditional GET request.
*
* @method isValidateable
* @return {Boolean} True if response is validateable otherwise, false
*&#x2F;
Response.prototype.isValidateable = function() {
    if ( this.getHeader( &#x27;Last-Modified&#x27; )  !== undefined || this.getHeader( &#x27;ETag&#x27; ) !== undefined ) {
        return true;
    } else {
        return false;
    }
};



&#x2F;**
* Set the time to live for the Response&#x27;s private cache. This method sets the 
*           Cache-Control and max-age directives
*
* @method setClientTtl
* @param {Number} seconds Set the number of seconds (added to the existing age) should 
            the private TTL be set to 
*&#x2F;
Response.prototype.setPrivateTtl = function( seconds ) {
    var age = this.getAge() &gt;&gt;&gt; 0;
    this.setMaxAge( age + seconds );
};


&#x2F;**
* Set the time to live for the Response&#x27;s shared cache. This method sets the 
*           Cache-Control and s-maxage directives
*
* @method setTtl
* @param {Number} seconds Set the number of seconds (added to the existing age) 
            should the shared TTL be set to 
*&#x2F;
Response.prototype.setTtl = function( seconds ) {
    var age = this.getAge() &gt;&gt;&gt; 0;
    this.setSharedMaxAge( age + seconds );
};



&#x2F;**
* Set the response content
*
* @method setContent
* @param {String} content String containing content
*&#x2F;
Response.prototype.setContent = function( content ) {
    this._content = content;
};



&#x2F;**
* Set the ETag header
*
* @method setEtag
* @param {String} value value to be set for the ETag header
* @param {Bool} weak boolean value indicating it is a weak Etag
*&#x2F;
Response.prototype.setETag = function( value, weak ) {
    if ( value === undefined ) {
        this.removeHeader( &#x27;Etag&#x27; );    
    } else {
        if ( value[0] !== &#x27;&quot;&#x27; ) {
            value = &#x27;&quot;&#x27; + value + &#x27;&quot;&#x27;;
        }
        if ( weak === true ) {
            value = &#x27;W&#x2F;&#x27; + value;
        }
        
        this.setHeader( &#x27;Etag&#x27;, value)
    }
};




&#x2F;**
* Set the vlaue of the &#x60;Expires&#x60; HTTP header.
*
* @method setExpires
* @param {Date} date Date object containing the time value to be set
*&#x2F;
Response.prototype.setExpires = function( date ) {
    if ( date === undefined ) {
        this.removeHeader( &#x27;Expires&#x27; );
    } else {
        this.setHeaderDate( &#x27;Expires&#x27;, date );
    } 
};



&#x2F;**
* Marks the response stale by setting the Age header to be equal to the maximum age of the response.
*
* @method setExpired
*&#x2F;
Response.prototype.setExpired = function() {
    if ( this.isFresh() ) {
        this.set( &#x27;Age&#x27;, this.getMaxAge() );
    }
};



&#x2F;**
* Set the value of the &#x60;Last-Modified&#x60; HTTP header with the specified Date object
*
* @method setLastModified
* @param {Date} date Instance of Date object holding date-time to be set as the last modified header
*&#x2F;
Response.prototype.setLastModified = function( date ) {
    if ( !date ) {
        this.remove( &#x27;Last-Modified&#x27; );
    } else {
        this.setHeaderDate( &#x27;Last-Modified&#x27;, date );
    }
};




&#x2F;**
* Sets the number of seconds after which the response should no longer be considered fresh
*
* @method setMaxAge
* @param {Number} seconds Number of seconds
*&#x2F;
Response.prototype.setMaxAge = function( seconds ) {
    this.addCacheControlDirective( &#x27;max-age&#x27;, seconds );
};




&#x2F;**
* Sets the number of seconds after which the response should no longer be 
            considered fresh by shared caches.
            This methods sets the Cache-Control s-maxage directive.
*
* @method setSharedMaxAge
* @param {Number} seconds Number of seconds
*&#x2F;
Response.prototype.setSharedMaxAge = function( seconds ) {
    this.setPublic();
    this.addCacheControlDirective( &#x27;s-maxage&#x27;, seconds );
};



&#x2F;*
    Function: 

        
*&#x2F;
&#x2F;**
* Set the response as a not modified (304). Will remove any HTTP headers that 
        might contradict this: &#x27;Allow&#x27;, &#x27;Content-Encoding&#x27;, &#x27;Content-Language&#x27;,
        &#x27;Content-Length&#x27;, &#x27;Content-MD5&#x27;, &#x27;Content-Type&#x27;, &#x27;Last-Modified&#x27;
*
* @method setNotModified
*&#x2F;
Response.prototype.setNotModified = function() {
    this.setStatusCode( 304 );
    this.setContent( &#x27;&#x27; );
    
    var headersNotAllowed = [ &#x27;Allow&#x27;, &#x27;Content-Encoding&#x27;, &#x27;Content-Language&#x27;,
        &#x27;Content-Length&#x27;, &#x27;Content-MD5&#x27;, &#x27;Content-Type&#x27;, &#x27;Last-Modified&#x27; ];
    for ( var i = 0, len = headersNotAllowed.length; i &lt; len; i ++) {
        this._response.removeHeader( headersNotAllowed[i] );
    }
};



&#x2F;**
* Set reponse as private. This makes the response ineligible for serving other clients.
*
* @method setPrivate
*&#x2F;
Response.prototype.setPrivate = function() {
    this.removeCacheControlDirective( &#x27;public&#x27; );
    this.addCacheControlDirective( &#x27;private&#x27; );
};



&#x2F;**
* Set reponse as public. This makes the response eligible for serving other clients.
*
* @method setPublic
*&#x2F;
Response.prototype.setPublic = function() {
    this.removeCacheControlDirective( &#x27;private&#x27; );
    this.addCacheControlDirective( &#x27;public&#x27; );
};



&#x2F;*
* Set the protoccol version of the response
*
* method setProtocolVersion
*&#x2F;
&#x2F;*
Response.prototype.setProtocolVersion = function() {
    
};
*&#x2F;


&#x2F;**
* Set HTTP status code to response
*
* @method setStatusCode
* @param {Number} status Status code
*&#x2F;
Response.prototype.setStatusCode = function( status ) {
    this._response.statusCode = status;
};



&#x2F;**
* Send headers + content to client thus ending the client&#x27;s request
*
* @method send
*&#x2F;
Response.prototype.send = function() {
    &#x2F;&#x2F;setup response cookies
    var cookies = [];
    for ( var cookie in this._cookies ) {
        cookies.push( this._cookies[ cookie ].toString() );
    }
    
    if ( cookies.length &gt; 0 ) {
        this._response.setHeader(&#x27;Set-Cookie&#x27;, cookies);
    }
    
    this._response.setHeader(&#x27;Content-Type&#x27;, this._contentType);
    this._response.end( this._content, this._encoding );
    
    this._sent = true;
};



&#x2F;**
* Send headers + content to client thus ending the client&#x27;s request
*
* @method send
*&#x2F;
Response.prototype.write = function( chunk, encoding ) {

    &#x2F;&#x2F;setup response cookies
    var cookies = [];
    for ( var cookie in this._cookies ) {
        cookies.push( this._cookies[ cookie ].toString() );
    }
    
    if ( cookies.length &gt; 0 ) {
        this._response.setHeader(&#x27;Set-Cookie&#x27;, cookies);
    }
    
    this._response.setHeader(&#x27;Content-Type&#x27;, this._contentType);
    this._response.end( this._content, this._encoding );
    
    
    this._response.write(chunk, this._encoding);
};

Response.prototype.end = function() {
    
};



&#x2F;**
* Get the value of the &#x60;Cache-Control&#x60; header
*
* @method _getCacheControlHeader
* @private
* @return {String} Cache-Control header value
*&#x2F;
Response.prototype._getCacheControlHeader = function() {
    var parts = [];
    for ( var directive in this._cacheControl ) {
        var value = this.cacheControl[ directive ];
        if ( value === true ) {
            parts.push( directive );
        } else {
            if( &#x2F;[^a-zA-Z0-9._-]&#x2F;.test( value ) ) {
                value = &#x27;&quot;&#x27; + value + &#x27;&quot;&#x27;;
            }
            parts.push( directive + &#x27;=&#x27; + value );
        }
    }
    
    return parts.join(&#x27;, &#x27;);
};



&#x2F;**
* Add a cache directive to &#x60;Cache-Control&#x60; header
*
* @method addCacheControlDirective
* @param {String} directie Directive
* @param {String} [value] Optional value for cache directive
*&#x2F;
Response.prototype.addCacheControlDirective = function( directive, value ) {
    if ( value === undefined ) {
        value = true;
    }
    this._cacheControl[ directive ] = value;
    
    this._updateCacheControl();
};



&#x2F;**
* Remove a cache directive to &#x60;Cache-Control&#x60; header
*
* @method removeCacheControlDirective
* @param {String} directie name of directive to remove form header
*&#x2F;
Response.prototype.removeCacheControlDirective = function( directive ) {
    delete this._cacheControl[ directive ];
    
    this._updateCacheControl();
};



&#x2F;**
* Get a cache directive to &#x60;Cache-Control&#x60; header
*
* @method getCacheControlDirective
* @param {String} directie name of directive to remove form header
* @return {String} Value of specified directive
*&#x2F;
Response.prototype.getCacheControlDirective = function( directive ) {
    return this._cacheControl[ directive ];
};



&#x2F;**
* Updates the &#x60;Cache-Control&#x60; header to user specified properties using Response&#x27;s methods 
*
* @method _updateCacheControl
* @private
* @param {String} directie name of directive to remove form header
* @return {String} Value of specified directive
*&#x2F;
Response.prototype._updateCacheControl = function() {
    this.set( &#x27;Cache-Control&#x27;, this._getCacheControlHeader() );
};




&#x2F;**
* Determines if the Response validators (ETag, Last-Modified) matches a conditional 
            value specified in the Request. If the response is not modified, it sets the 
            status code to 304 and removes the response content by calling the &#x60;setNotModified&#x60; method
*
* @method isNotModified
* @return {Boolean} True if the request and response cache validators match, otherwise false
*&#x2F;
Response.prototype.isNotModified = function() {
    var lastModified = this._request.get( &#x27;If-Modified-Since&#x27; );
    var notModified = false;
    var etag = this._request.getEtag();
    
    if ( !etag ) {
        notModified = ( ~etags.indexOf( this.getEtag() ) || ~etags.indexOf( &#x27;*&#x27; ) ) &amp;&amp; ( !lastModified || this.getDate( &#x27;Last-Modified&#x27; ).valueOf() === lastModified.valueOf() );
    } else if ( lastModified ) {
        notModified = lastModified.valueOf() === this.get( &#x27;Last-Modified&#x27; ).valueOf();
    }
    
    if ( setNotModified ) {
        this.setNotModified();
    }
    
    return notModified;
};



&#x2F;**
* Determine if the response is invalid by looking at the status code
*
* @method isInvalid
* @return {Boolean} true if the response is invalid, otherwise false
*&#x2F;
Response.prototype.isInvalid = function() {
    return this.statusCode() &lt; 100 || this.statusCode() &gt;= 600;
};



&#x2F;**
* Determine if the response is just informative by looking at the status code
*
* @method isInformational
* @return {Boolean} true if the response is informative, otherwise false
*&#x2F;
Response.prototype.isInformational = function() {
    return this.statusCode() &gt;= 100 &amp;&amp; this.statusCode() &lt; 200;
};



&#x2F;**
* Determine if the response is successful by looking at the status code
*
* @method isSuccessful
* @return {Boolean} true if the response is successful, otherwise false
*&#x2F;
Response.prototype.isSuccessful = function() {
    return this.statusCode() &gt;= 200 &amp;&amp; this.statusCode() &lt; 300;
};



&#x2F;**
* Determine if the response is a redirect by looking at the status code
*
* @method isRedirection
* @return {Boolean} true if the response is a redirect, otherwise false
*&#x2F;
Response.prototype.isRedirection = function() {
    return this.statusCode() &gt;= 300 &amp;&amp; this.statusCode() &lt; 400;
};


&#x2F;**
* Determine if the response is a client error by looking at the status code
*
* @method isClientError
* @return {Boolean} true if the response is a client error, otherwise false
*&#x2F;
Response.prototype.isClientError = function() {
    return this.statusCode() &gt;= 400 &amp;&amp; this.statusCode() &lt; 500;
};



&#x2F;**
* Determine if the response is a server error by looking at the status code
*
* @method isServerError
* @return {Boolean} true if the response is a server error, otherwise false
*&#x2F;
Response.prototype.isServerError = function() {
    return this.statusCode() &gt;= 500 &amp;&amp; this.statusCode() &lt; 600;
};



&#x2F;**
* Determine if the response is OK by looking at the status code (200)
*
* @method isOk
* @return {Boolean} true if the response is OK, otherwise false
*&#x2F;
Response.prototype.isOk = function() {
    return this.statusCode() === 200;
};



&#x2F;**
* Determine if the response is forbidden by looking at the status code
*
* @method isForbidden
* @return {Boolean} true if the response is forbidden, otherwise false
*&#x2F;
Response.prototype.isForbidden = function() {
    return this.statusCode() === 403;
};



&#x2F;**
* Determine if the response is a &#x60;not found&#x60; by looking at the status code (404)
*
* @method isNotFound
* @return {Boolean} true if the response is &#x27;not found&#x27;, otherwise false
*&#x2F;
Response.prototype.isNotFound = function() {
    return this.statusCode() === 404;
};


&#x2F;**
* Determine if the response is empty by looking at the status code
*
* @method isEmpty
* @return {Boolean} true if the response is valid, otherwise false
*&#x2F;
Response.prototype.isEmpty = function() {
    return ( this.statusCode() === 201 || this.statusCode() === 204 || this.statusCode() === 304 );
};




&#x2F;**
* Set HTTP header and it&#x27;s value
*
* @method set
* @param {String} header HTTP Header name
* @param {String} value Header value
*&#x2F;
Response.prototype.set = function( header, value ) {
    this._response.setHeader( header, value );
};




&#x2F;**
* Get the specified HTTP header&#x27;s value
*
* @method get
* @param {String} header HTTP Header name
* @return {String} Specified Header&#x27;s value
*&#x2F;
Response.prototype.get = function( header ) {
    return this._response.getHeader( header );
};



&#x2F;**
* Remove the specified HTTP header
*
* @method remove
* @param {String} header HTTP Header name
*&#x2F;
Response.prototype.remove = function( header ) {
    this._response.removeHeader( header );
};




&#x2F;**
* Set a cookie by passing in its properties, including it&#x27;s name. 
            see &lt;Cookie&gt; for the supported properties
*
* @method addCookie
* @param {Object} Properties&#x2F;directives of the cookie
*&#x2F;
Response.prototype.addCookie = function( properties ) {
    if ( !properties.name ) {
        throw Error( &#x27;name: &quot;Bad Cookie&quot;, description: &quot;Function requires valid cookie name&quot;&#x27; );
    }
    this._cookies[ properties.name ] = new Cookie( properties );
};



&#x2F;**
* Get the specified cookie as a &#x60;Cookie&#x60; object
*
* @method getCookie
* @param {String} name Name of cookie
* @return {Object&#x2F;Cookie} requested cookie
*&#x2F;
Response.prototype.getCookie = function( name ) {
    return this._cookies[ name ];
};



&#x2F;**
* Remove a cookie from client browser by setting its &#x60;Expires&#x60; directive
*
* @method removeCookie
* @param {String} name Name of cookie
*&#x2F;
Response.prototype.removeCookie = function( name ) {
    if ( !name ) {
        throw Error( &#x27;name: &quot;Bad Cookie&quot;, description: &quot;Function requires valid cookie name&quot;&#x27; );
    }

    var cookie;
    if ( this._cookies[name] ) {
        cookie = this._cookies[name];
        cookie.setValue(&#x27;&#x27;);
    } else {
        cookie = new Cookie({name: name, value: &#x27;&#x27;});
    }

    cookie.setExpires(new Date(0));
};



&#x2F;**
* Render the response and end it
*
* @method render
* @param {String} viewName Name of the view to render
* @param {Object} props Object holding values to pass to rendering engine
*&#x2F;
Response.prototype.render = function( viewName, props ) {
    var applet = this._request.getApplet();
    var content = this._firefly.renderer.render( applet, viewName, props );
    this.setContent( content );
    this.send();
};



&#x2F;**
* Set response &#x60;Content-Type&#x60; header&#x27;s value. firefly, by default sets it to text&#x2F;html
*
* @method setContentType
* @param {String} contentType Value of Content-Type header
*&#x2F;
Response.prototype.setContentType = function( contentType ) {
    this._contentType = contentType;
};



&#x2F;**
* Get response &#x60;Content-Type&#x60; header&#x27;s value
*
* @method getContentType
* @param {String} contentType Value of Content-Type header
*&#x2F;
Response.prototype.getContentType = function() {
    return this._contentType;
};



&#x2F;**
* Redirect user to another URL
*
* @method redirect
*&#x2F;
Response.prototype.redirect = function( url ) {
    this.setStatusCode(303);
    this._response.setHeader(&#x27;Location&#x27;, url);
    this.setContent(&#x27;&#x27;);
    this.send();
};

&#x2F;&#x2F;TODO: upgrade to TLS headers
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
